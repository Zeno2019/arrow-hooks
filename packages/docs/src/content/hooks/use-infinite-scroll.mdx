---
title: useInfiniteScroll
description: ç”¨äºå®ç°æ— é™æ»šåŠ¨çš„ React Hook
---

import { InfiniteScrollExample } from '@/components/examples';

# useInfiniteScroll

ç”¨äºå®ç°æ— é™æ»šåŠ¨çš„ React Hookï¼ŒåŸºäº useIntersectionObserver å’Œé˜²æŠ–æŠ€æœ¯ï¼Œå½“æ»šåŠ¨åˆ°åº•éƒ¨æ—¶è‡ªåŠ¨åŠ è½½æ›´å¤šæ•°æ®ï¼Œå¸¸ç”¨äºæ–°é—»æµã€å•†å“åˆ—è¡¨ã€ç¤¾äº¤åª’ä½“åŠ¨æ€ç­‰åœºæ™¯ã€‚

## åœ¨çº¿æ¼”ç¤º

<InfiniteScrollExample />

## åŸºæœ¬ç”¨æ³•

```tsx tab="React å‡½æ•°ç»„ä»¶"
import { useInfiniteScroll } from 'arrow-hooks'
import { useRef, useState, useCallback } from 'react'

function App() {
  const [items, setItems] = useState<string[]>([])
  const [hasMore, setHasMore] = useState(true)
  const loaderRef = useRef<HTMLDivElement>(null)

  const loadMore = useCallback(async () => {
    // æ¨¡æ‹Ÿ API è¯·æ±‚
    await new Promise(resolve => setTimeout(resolve, 1000))

    const newItems = Array.from({ length: 10 }, (_, i) =>
      `Item ${items.length + i + 1}`
    )

    setItems(prev => [...prev, ...newItems])

    // æ¨¡æ‹Ÿæ•°æ®ä¸Šé™
    if (items.length + newItems.length >= 100) {
      setHasMore(false)
    }
  }, [items.length])

  const isLoading = useInfiniteScroll(loaderRef, loadMore, {
    hasMore,
    threshold: 0.5
  })

  return (
    <div style={{ height: '400px', overflowY: 'auto' }}>
      {items.map((item, index) => (
        <div key={index} style={{ padding: '1rem', borderBottom: '1px solid #eee' }}>
          {item}
        </div>
      ))}

      <div ref={loaderRef} style={{ padding: '1rem', textAlign: 'center' }}>
        {isLoading ? 'åŠ è½½ä¸­...' : hasMore ? 'æ»šåŠ¨åŠ è½½æ›´å¤š' : 'æ²¡æœ‰æ›´å¤šäº†'}
      </div>
    </div>
  )
}
```

## ä½¿ç”¨åœºæ™¯

### 1. å•†å“åˆ—è¡¨

ç”µå•†ç½‘ç«™çš„å•†å“æ— é™æ»šåŠ¨åŠ è½½ï¼š

```tsx
import { useInfiniteScroll } from 'arrow-hooks'
import { useRef, useState, useCallback } from 'react'

interface Product {
  id: number
  name: string
  price: number
  image: string
}

function ProductList() {
  const [products, setProducts] = useState<Product[]>([])
  const [hasMore, setHasMore] = useState(true)
  const [page, setPage] = useState(1)
  const loaderRef = useRef<HTMLDivElement>(null)

  const loadProducts = useCallback(async () => {
    try {
      const response = await fetch(`/api/products?page=${page}&limit=20`)
      const data = await response.json()

      if (data.products.length === 0) {
        setHasMore(false)
        return
      }

      setProducts(prev => [...prev, ...data.products])
      setPage(prev => prev + 1)

      // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
      if (data.products.length < 20) {
        setHasMore(false)
      }
    } catch (error) {
      console.error('åŠ è½½å•†å“å¤±è´¥:', error)
    }
  }, [page])

  const isLoading = useInfiniteScroll(loaderRef, loadProducts, {
    hasMore,
    threshold: 0.3,
    rootMargin: '100px'
  })

  return (
    <div className="product-grid">
      {products.map(product => (
        <div key={product.id} className="product-card">
          <img src={product.image} alt={product.name} />
          <h3>{product.name}</h3>
          <p className="price">Â¥{product.price}</p>
        </div>
      ))}

      <div ref={loaderRef} className="loader">
        {isLoading && <div className="loading-spinner">åŠ è½½ä¸­...</div>}
        {!hasMore && <div className="no-more">æ²¡æœ‰æ›´å¤šå•†å“äº†</div>}
      </div>
    </div>
  )
}
```

### 2. ç¤¾äº¤åª’ä½“åŠ¨æ€

ç±»ä¼¼å¾®åšã€æœ‹å‹åœˆçš„åŠ¨æ€æµï¼š

```tsx
import { useInfiniteScroll } from 'arrow-hooks'
import { useRef, useState, useCallback } from 'react'

interface Post {
  id: string
  user: string
  content: string
  timestamp: string
  likes: number
}

function SocialFeed() {
  const [posts, setPosts] = useState<Post[]>([])
  const [hasMore, setHasMore] = useState(true)
  const [lastId, setLastId] = useState<string>('')
  const loaderRef = useRef<HTMLDivElement>(null)

  const loadPosts = useCallback(async () => {
    try {
      const response = await fetch(`/api/posts?lastId=${lastId}&limit=10`)
      const data = await response.json()

      if (data.posts.length === 0) {
        setHasMore(false)
        return
      }

      setPosts(prev => [...prev, ...data.posts])
      setLastId(data.posts[data.posts.length - 1].id)

      if (data.posts.length < 10) {
        setHasMore(false)
      }
    } catch (error) {
      console.error('åŠ è½½åŠ¨æ€å¤±è´¥:', error)
    }
  }, [lastId])

  const isLoading = useInfiniteScroll(loaderRef, loadPosts, {
    hasMore,
    delay: 300, // 300ms é˜²æŠ–
    threshold: 0.5
  })

  return (
    <div className="social-feed">
      {posts.map(post => (
        <article key={post.id} className="post">
          <header>
            <strong>{post.user}</strong>
            <time>{post.timestamp}</time>
          </header>
          <p>{post.content}</p>
          <footer>
            <button>ğŸ‘ {post.likes}</button>
            <button>ğŸ’¬ è¯„è®º</button>
            <button>ğŸ”„ è½¬å‘</button>
          </footer>
        </article>
      ))}

      <div ref={loaderRef} className="load-more">
        {isLoading ? (
          <div>ğŸ“± æ­£åœ¨åŠ è½½æ–°åŠ¨æ€...</div>
        ) : hasMore ? (
          <div>ğŸ‘‡ ç»§ç»­æ»‘åŠ¨æŸ¥çœ‹æ›´å¤š</div>
        ) : (
          <div>ğŸ‰ ä½ å·²ç»çœ‹å®Œæ‰€æœ‰åŠ¨æ€äº†</div>
        )}
      </div>
    </div>
  )
}
```

### 3. æœç´¢ç»“æœé¡µ

æœç´¢ç»“æœçš„åˆ†é¡µåŠ è½½ï¼š

```tsx
import { useInfiniteScroll } from 'arrow-hooks'
import { useRef, useState, useCallback, useEffect } from 'react'

interface SearchResult {
  id: string
  title: string
  description: string
  url: string
}

function SearchResults({ query }: { query: string }) {
  const [results, setResults] = useState<SearchResult[]>([])
  const [hasMore, setHasMore] = useState(true)
  const [page, setPage] = useState(1)
  const loaderRef = useRef<HTMLDivElement>(null)

  // é‡ç½®æœç´¢ç»“æœ
  useEffect(() => {
    setResults([])
    setPage(1)
    setHasMore(true)
  }, [query])

  const searchMore = useCallback(async () => {
    if (!query.trim()) return

    try {
      const response = await fetch(
        `/api/search?q=${encodeURIComponent(query)}&page=${page}&limit=10`
      )
      const data = await response.json()

      if (data.results.length === 0) {
        setHasMore(false)
        return
      }

      setResults(prev => page === 1 ? data.results : [...prev, ...data.results])
      setPage(prev => prev + 1)

      if (data.results.length < 10) {
        setHasMore(false)
      }
    } catch (error) {
      console.error('æœç´¢å¤±è´¥:', error)
    }
  }, [query, page])

  const isLoading = useInfiniteScroll(loaderRef, searchMore, {
    hasMore: hasMore && query.trim() !== '',
    threshold: 0.8,
    delay: 500
  })

  if (!query.trim()) {
    return <div className="search-placeholder">è¯·è¾“å…¥æœç´¢å…³é”®è¯</div>
  }

  return (
    <div className="search-results">
      <div className="results-info">
        æ‰¾åˆ° {results.length}+ ä¸ªç»“æœï¼Œæœç´¢ï¼š{query}
      </div>

      {results.map(result => (
        <div key={result.id} className="result-item">
          <h3>
            <a href={result.url} target="_blank" rel="noopener noreferrer">
              {result.title}
            </a>
          </h3>
          <p>{result.description}</p>
          <cite>{result.url}</cite>
        </div>
      ))}

      <div ref={loaderRef} className="search-loader">
        {isLoading ? (
          <div>ğŸ” æœç´¢æ›´å¤šç»“æœ...</div>
        ) : hasMore ? (
          <div>ç»§ç»­æ»šåŠ¨æŸ¥çœ‹æ›´å¤šç»“æœ</div>
        ) : (
          <div>å·²æ˜¾ç¤ºæ‰€æœ‰æœç´¢ç»“æœ</div>
        )}
      </div>
    </div>
  )
}
```

### 4. å›¾ç‰‡ç”»å»Š

å›¾ç‰‡æ‡’åŠ è½½çš„æ— é™æ»šåŠ¨ç”»å»Šï¼š

```tsx
import { useInfiniteScroll } from 'arrow-hooks'
import { useRef, useState, useCallback } from 'react'

interface Photo {
  id: string
  url: string
  thumbnail: string
  title: string
  photographer: string
}

function PhotoGallery() {
  const [photos, setPhotos] = useState<Photo[]>([])
  const [hasMore, setHasMore] = useState(true)
  const [page, setPage] = useState(1)
  const loaderRef = useRef<HTMLDivElement>(null)

  const loadPhotos = useCallback(async () => {
    try {
      const response = await fetch(`/api/photos?page=${page}&per_page=12`)
      const data = await response.json()

      if (data.photos.length === 0) {
        setHasMore(false)
        return
      }

      setPhotos(prev => [...prev, ...data.photos])
      setPage(prev => prev + 1)

      if (data.photos.length < 12) {
        setHasMore(false)
      }
    } catch (error) {
      console.error('åŠ è½½å›¾ç‰‡å¤±è´¥:', error)
    }
  }, [page])

  const isLoading = useInfiniteScroll(loaderRef, loadPhotos, {
    hasMore,
    threshold: 0.2, // æ›´æ—©å¼€å§‹åŠ è½½
    rootMargin: '200px' // æå‰200pxå¼€å§‹åŠ è½½
  })

  return (
    <div className="photo-gallery">
      <div className="gallery-grid">
        {photos.map(photo => (
          <div key={photo.id} className="photo-item">
            <img
              src={photo.thumbnail}
              alt={photo.title}
              loading="lazy"
              onClick={() => openLightbox(photo.url)}
            />
            <div className="photo-info">
              <h4>{photo.title}</h4>
              <p>by {photo.photographer}</p>
            </div>
          </div>
        ))}
      </div>

      <div ref={loaderRef} className="gallery-loader">
        {isLoading ? (
          <div className="loading-grid">
            {Array.from({ length: 4 }, (_, i) => (
              <div key={i} className="loading-placeholder" />
            ))}
          </div>
        ) : hasMore ? (
          <div>ç»§ç»­æµè§ˆæ›´å¤šç²¾ç¾å›¾ç‰‡</div>
        ) : (
          <div>ğŸ¨ å·²æµè§ˆå®Œæ‰€æœ‰å›¾ç‰‡</div>
        )}
      </div>
    </div>
  )
}

function openLightbox(url: string) {
  // æ‰“å¼€å›¾ç‰‡ç¯ç®±
}
```

## API å‚è€ƒ

### å‚æ•°

| å‚æ•° | ç±»å‹ | é»˜è®¤å€¼ | æè¿° |
|------|------|--------|------|
| targetRef | RefObject\<Element\> | - | è§¦å‘å…ƒç´ çš„å¼•ç”¨ï¼ˆé€šå¸¸æ˜¯åŠ è½½æŒ‡ç¤ºå™¨ï¼‰ |
| onLoadMore | () => Promise\<void\> \| void | - | åŠ è½½æ›´å¤šæ•°æ®çš„å›è°ƒå‡½æ•° |
| options | UseInfiniteScrollOptions | {} | é…ç½®é€‰é¡¹ |

### è¿”å›å€¼

| ç±»å‹ | æè¿° |
|------|------|
| boolean | æ˜¯å¦æ­£åœ¨åŠ è½½ä¸­ |

### é…ç½®é€‰é¡¹

```tsx
interface UseInfiniteScrollOptions extends IntersectionObserverInit {
  hasMore?: boolean    // æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®ï¼Œé»˜è®¤ true
  isLoading?: boolean  // å¤–éƒ¨åŠ è½½çŠ¶æ€ï¼Œé»˜è®¤ false
  delay?: number       // é˜²æŠ–å»¶è¿Ÿæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤ 100
}

// ç»§æ‰¿çš„ IntersectionObserverInit é€‰é¡¹ï¼š
interface IntersectionObserverInit {
  threshold?: number | number[]  // è§¦å‘é˜ˆå€¼ï¼Œé»˜è®¤ 0.5
  rootMargin?: string           // æ ¹è¾¹è·ï¼Œé»˜è®¤ '0px'
  root?: Element | null         // æ ¹å…ƒç´ ï¼Œé»˜è®¤ä¸ºè§†å£
}
```

### ä½¿ç”¨ç¤ºä¾‹

```tsx
import { useInfiniteScroll } from 'arrow-hooks'

// åŸºç¡€ç”¨æ³•
const isLoading = useInfiniteScroll(loaderRef, loadMore, {
  hasMore: true
})

// è‡ªå®šä¹‰è§¦å‘æ¡ä»¶
const isLoading = useInfiniteScroll(loaderRef, loadMore, {
  hasMore: items.length < totalCount,
  threshold: 0.8,      // 80% å¯è§æ—¶è§¦å‘
  rootMargin: '100px', // æå‰ 100px è§¦å‘
  delay: 300          // 300ms é˜²æŠ–
})

// ç»“åˆå¤–éƒ¨åŠ è½½çŠ¶æ€
const isLoading = useInfiniteScroll(loaderRef, loadMore, {
  hasMore: hasMoreData,
  isLoading: externalLoadingState,
  delay: 500
})
```

## æ³¨æ„äº‹é¡¹

- **é˜²æŠ–ä¼˜åŒ–**: å†…ç½®é˜²æŠ–æœºåˆ¶ï¼Œé¿å…å¿«é€Ÿæ»šåŠ¨æ—¶çš„é‡å¤è¯·æ±‚
- **é”™è¯¯å¤„ç†**: å»ºè®®åœ¨ onLoadMore ä¸­æ·»åŠ é”™è¯¯å¤„ç†é€»è¾‘
- **åŠ è½½çŠ¶æ€**: è¿”å›çš„ isLoading çŠ¶æ€ç”¨äºæ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
- **æ€§èƒ½è€ƒè™‘**: å¤§é‡æ•°æ®æ—¶è€ƒè™‘è™šæ‹Ÿæ»šåŠ¨æŠ€æœ¯ä¼˜åŒ–æ€§èƒ½
- **ç½‘ç»œä¼˜åŒ–**: å¯ä»¥ç»“åˆé¢„åŠ è½½å’Œç¼“å­˜ç­–ç•¥æå‡ç”¨æˆ·ä½“éªŒ
- **è§¦å‘ä½ç½®**: é€šè¿‡ threshold å’Œ rootMargin æ§åˆ¶ä½•æ—¶å¼€å§‹åŠ è½½
- **æ•°æ®å»é‡**: ç¡®ä¿ API è¿”å›çš„æ•°æ®æ²¡æœ‰é‡å¤é¡¹
- **å†…å­˜ç®¡ç†**: å¤§é‡æ•°æ®æ—¶è€ƒè™‘å®ç°æ•°æ®å›æ”¶æœºåˆ¶